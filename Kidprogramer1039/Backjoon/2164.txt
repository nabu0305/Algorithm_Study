내 풀이
from collections import deque

n = int(input())
queue = deque([])
for i in range(1, n+1):
    queue.append(i)

while True:
        queue.popleft()
        if len(queue) == 1:
            break
        else:
            queue.append(queue[0])
라고 적었으나..
시간 초과가 떠 버렸다.

그래서 수정을 해서
from collections import deque

n = int(input())
queue = deque([])
copy = deque([])
for i in range(1, n+1):
    queue.append(i)
    copy.append(i)
while True:
        queue.popleft()
        if len(queue) == 1:
            break
        else:
            queue.append(copy[0])
            copy.popleft()        
로 제출했는데 이번엔 런타임 에러가 떠버린다.

그래서 일단은 40분을 넘겼으니 시간 초과 문제에 대한 해답은 나중에 찾는걸로 하고,
답안을 분석하는 걸로 했다.

답안 
n = int(input())
nums = []  #큐 배열 지정
for i in range(n): #배열에 입력받은 수 만큼 배열 추가
  nums.append(i+1)
front = 0
back = n-1

while back - front != 0: #큐의 길이가 1이 될 때까지 
  front += 1 #맨 앞 숫자 삭제
  num.append(nums[front]) #파이썬 append 함수를 활용하여 맨 뒤에 숫자 추가
  front += 1  #front좌표 및 back좌표 오른쪽으로 1칸씩 이동
  back += 1
  
느낀 점 및 배운점
여기서 깨달은 점은, 좌표 하나면 어지간한 쉬운 큐 문제들은 대부분 해결할 수도 있지 않을까 하는 생각이었다.
아까 18258번도 그렇고, 필수적인 상황이 아니고 단순히 1개만 출력하는 문제들이라면, 역으로 저렇게 좌표를 남기는 것이 정석이 아닐까 하는 생각이 들었다.
아무래도 큐에 대한 예제를 따로 더 풀어볼 필요성이 있어보인다.
